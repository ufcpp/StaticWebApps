@using BinaryTool.Dom;
@using BinaryTool.Markup;

<style>
    li.map > span.key {
        color: lightseagreen;
    }

    li.list > span.key {
        color: lightcoral;
    }

    .tree {
        font-family: 'Cascadia Mono', monospace;
    }

    .tree .error {
        color: red;
    }

    .source {
        font-family: 'Cascadia Mono', monospace;
    }

    .source span.node { background-color: #c0c0c0; }
    .source span.node span.node { background-color: #d3c9ff; }
    .source span.node span.node span.node { background-color: #c9e2ff; }
    .source span.node span.node span.node span.node { background-color: #c9ffee; }
    .source span.node span.node span.node span.node span.node { background-color: #dcffc9; }
    .source span.node span.node span.node span.node span.node span.node { background-color: #fffdc9; }
    .source span.node span.node span.node span.node span.node span.node span.node { background-color: #ffe3c9; }
    .source span.node span.node span.node span.node span.node span.node span.node span.node { background-color: #ffc9c9; }

    .source .map > .body {
        color: darkred;
    }

    .source .list > .body {
        color: darkblue;
    }

    .source .other > .body {
        color: black;
    }

    .source .key {
        color: lightseagreen;
    }

    .source .trail {
        color: gray;
    }
</style>

<Selector Label="DOM" Items="ILoader.DefaultLoaders" @bind-SelectedItem="SelectedLoader" />

@{
    void RenderUl(IReadOnlyList<Dom.DomSpan> spans, int i) => RenderUlInternal(spans, i);

    int RenderUlInternal(IReadOnlyList < Dom.DomSpan > spans, int i)
    {
        var span = spans[i];

        ++i;

        if (span.Kind is Dom.DomKind.Map or Dom.DomKind.List)
        {
            var className = span.Kind switch
            {
                Dom.DomKind.Map => "map",
                Dom.DomKind.List => "list",
                _ => "other",
            };

            <ul>
                @for (int j = 0; j < span.Length; j++)
                {
                    <li class="@className">
                        <span class="key">@spans[i].Key : </span>
                        @{
                            i = RenderUlInternal(spans, i);
                        }
                    </li>
                }
            </ul>
        }
        else if (span.Value is Exception ex)
        {
            <span class="error">
                Error at @span.Start,
                Message: @ex.Message
            </span>
        }
        else
        {
            @toString(span.Value)
        }

        return i;
    }
}

@if (Results is { } r)
{
    var data = InputBinary!;
    var tags = r.Build(data.Length);
    var html = tags.ToHtml(data, IsBinary);

    /*
    // for Debug
    var tt = tags.ToArray();
    <hr/>
    <ul>
        @foreach (var span in r)
        {
            var next = r.ElementAtOrDefault(span.NextIndex)?.KeyStart ?? data.Length;
            <li>@span.KeyStart, @span.Start, @span.End, @next, @span.Kind, @span.NextIndex</li>
        }
    </ul>

    <hr />
    <ul>
        @foreach (var tag in tt)
        {
            <li>@tag.Position, @tag.OppositePosition, @(tag.IsClose ? $"/{tag.Kind}" : $"{tag.Kind}")</li>
        }
    </ul>

    <div class="source">
        @html
    </div>
    //*/

    <div class="source">
        @(new MarkupString(html))
    </div>

    <div class="tree">
        @{RenderUl(r, 0);}
    </div>
}

@code {
    [Parameter] public byte[]? InputBinary { get; set; }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        Change();
    }

    private ILoader SelectedLoader { get => _loader!; set { _loader = value; Change(); } }
    private ILoader? _loader;

    private void Change()
    {
        (Results, IsBinary) = InputBinary is { } data && _loader is { } loader ? loader.Parse(data) : default;
    }

    public IReadOnlyList<Dom.DomSpan>? Results { get; set; }
    public bool IsBinary { get; set; }

    static string toString(object? value) => value switch
    {
        null => "null",
        true => "true",
        false => "false",
        string s => $"\"{s}\"",
        DateTime d => d.ToString(@"yyyy-MM-dd hh:mm:ss"),
        { } x => x.ToString()!,
    };
}
