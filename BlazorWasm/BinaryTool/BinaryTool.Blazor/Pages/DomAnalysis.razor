@using BinaryTool.Dom;
@using BinaryTool.Dom.Reader;
@using BinaryTool.Markup;

<style>
    li.map > span.key {
        color: lightseagreen;
    }

    li.list > span.key {
        color: lightcoral;
    }

    .tree {
        font-family: 'Cascadia Mono', monospace;
    }

    .tree .error {
        color: red;
    }

    .tree .keyword {
        color: blue;
    }

    .tree .string {
        color: darkred;
    }

    .tree .other {
        color: black;
    }

    .source {
        font-family: 'Cascadia Mono', monospace;
    }

    .source span.node { background-color: #c0c0c0; }
    .source span.node span.node { background-color: #d3c9ff; }
    .source span.node span.node span.node { background-color: #c9e2ff; }
    .source span.node span.node span.node span.node { background-color: #c9ffee; }
    .source span.node span.node span.node span.node span.node { background-color: #dcffc9; }
    .source span.node span.node span.node span.node span.node span.node { background-color: #fffdc9; }
    .source span.node span.node span.node span.node span.node span.node span.node { background-color: #ffe3c9; }
    .source span.node span.node span.node span.node span.node span.node span.node span.node { background-color: #ffc9c9; }

    .source .map > .body {
        color: darkred;
    }

    .source .list > .body {
        color: darkblue;
    }

    .source .other > .body {
        color: black;
    }

    .source .key {
        color: lightseagreen;
    }

    .source .trail {
        color: gray;
    }
</style>

<Selector Label="DOM" Items="IReader.DefaultReaders" @bind-SelectedItem="SelectedLoader" />

@{
    void RenderUl(IReadOnlyList<Dom.DomSpan> spans, int i) => RenderUlInternal(spans, i);

    int RenderUlInternal(IReadOnlyList < Dom.DomSpan > spans, int i)
    {
        var span = spans[i];

        ++i;

        if (span.Kind is BinaryTool.Dom.DomKind.Map or BinaryTool.Dom.DomKind.List)
        {
            var className = span.Kind switch
            {
                BinaryTool.Dom.DomKind.Map => "map",
                BinaryTool.Dom.DomKind.List => "list",
                _ => "other",
            };

            <ul>
                @for (int j = 0; j < span.Length; j++)
                {
                    <li class="@className">
                        <span class="key">@spans[i].Key : </span>
                        @{
                            i = RenderUlInternal(spans, i);
                        }
                    </li>
                }
            </ul>
        }
        else if (span.Value is Exception ex)
        {
            <span class="error">
                Error at @span.Start,
                Message: @ex.Message
            </span>
        }
        else
        {
            var (str, cls) = span.Value switch
            {
                null => ("null", "keyword"),
                true => ("true", "keyword"),
                false => ("false", "keyword"),
                string s => ($"\"{s}\"", "string"),
                DateTime d => (d.ToString(@"yyyy-MM-dd hh:mm:ss"), "other"),
                { } x => (x.ToString()!, "other"),
            };
            <span class="@cls">
                @str
            </span>
        }

        return i;
    }
}

@if (Dom is { } r)
{
    var data = _binary!;
    var tags = r.Build(data.Length);
    var html = tags.ToHtml(data, IsBinary);

    /*
    // for Debug
    var tt = tags.ToArray();
    <hr/>
    <ul>
        @foreach (var span in r)
        {
            var next = r.ElementAtOrDefault(span.NextIndex)?.KeyStart ?? data.Length;
            <li>@span.KeyStart, @span.Start, @span.End, @next, @span.Kind, @span.NextIndex</li>
        }
    </ul>

    <hr />
    <ul>
        @foreach (var tag in tt)
        {
            <li>@tag.Position, @tag.OppositePosition, @(tag.IsClose ? $"/{tag.Kind}" : $"{tag.Kind}")</li>
        }
    </ul>

    <div class="source">
        @html
    </div>
    //*/

    <div class="source">
        @(new MarkupString(html))
    </div>

    <div class="tree">
        @{RenderUl(r, 0);}
    </div>
}

@code {
    [Parameter] public byte[]? Binary { get; set; }

    private byte[]? _binary;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (_binary != Binary)
        {
            _binary = Binary;
            Change();
        }
    }

    private IReader SelectedLoader { get => _loader!; set { _loader = value; Change(); } }
    private IReader? _loader;

    private void Change()
    {
        (Dom, IsBinary) = _binary is { } data && _loader is { } loader ? loader.Read(data) : default;
        DomChanged.InvokeAsync(Dom);
        IsBinaryChanged.InvokeAsync(IsBinary);
    }

    [Parameter]
    public IReadOnlyList<Dom.DomSpan>? Dom { get; set; }

    [Parameter]
    public EventCallback<IReadOnlyList<Dom.DomSpan>?> DomChanged { get; set; }

    [Parameter]
    public bool IsBinary { get; set; }

    [Parameter]
    public EventCallback<bool> IsBinaryChanged { get; set; }
}
